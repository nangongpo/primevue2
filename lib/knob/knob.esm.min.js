var n={name:"Knob",data:function(){return{radius:40,midX:50,midY:50,minRadians:4*Math.PI/3,maxRadians:-Math.PI/3}},props:{value:{type:Number,default:null},size:{type:Number,default:100},disabled:{type:Boolean,default:!1},readonly:{type:Boolean,default:!1},step:{type:Number,default:1},min:{type:Number,default:0},max:{type:Number,default:100},valueColor:{type:String,default:"var(--primary-color, Black)"},rangeColor:{type:String,default:"var(--surface-border, LightGray)"},textColor:{type:String,default:"var(--text-color-secondary, Black)"},strokeWidth:{type:Number,default:14},showValue:{type:Boolean,default:!0},valueTemplate:{type:String,default:"{value}"}},methods:{updateValue:function(n,e){var t=Math.atan2(this.size/2-e,n-this.size/2),i=-Math.PI/2-Math.PI/6;this.updateModel(t,i)},updateModel:function(n,e){var t;if(n>this.maxRadians)t=this.mapRange(n,this.minRadians,this.maxRadians,this.min,this.max);else{if(!(n<e))return;t=this.mapRange(n+2*Math.PI,this.minRadians,this.maxRadians,this.min,this.max)}var i=Math.round((t-this.min)/this.step)*this.step+this.min;this.$emit("input",i),this.$emit("change",i)},mapRange:function(n,e,t,i,a){return(n-e)*(a-i)/(t-e)+i},onClick:function(n){this.disabled||this.readonly||this.updateValue(n.offsetX,n.offsetY)},onMouseDown:function(n){this.disabled||this.readonly||(window.addEventListener("mousemove",this.onMouseMove),window.addEventListener("mouseup",this.onMouseUp),n.preventDefault())},onMouseUp:function(n){this.disabled||this.readonly||(window.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("mouseup",this.onMouseUp),n.preventDefault())},onTouchStart:function(n){this.disabled||this.readonly||(window.addEventListener("touchmove",this.onTouchMove),window.addEventListener("touchend",this.onTouchEnd),n.preventDefault())},onTouchEnd:function(n){this.disabled||this.readonly||(window.removeEventListener("touchmove",this.onTouchMove),window.removeEventListener("touchend",this.onTouchEnd),n.preventDefault())},onMouseMove:function(n){this.disabled||this.readonly||(this.updateValue(n.offsetX,n.offsetY),n.preventDefault())},onTouchMove:function(n){if(!this.disabled&&!this.readonly&&1==n.touches.length){var e=this.$el.getBoundingClientRect(),t=n.targetTouches.item(0);this.updateValue(t.clientX-e.left,t.clientY-e.top)}}},computed:{containerClass:function(){return["p-knob p-component",{"p-disabled":this.disabled}]},rangePath:function(){return"M ".concat(this.minX," ").concat(this.minY," A ").concat(this.radius," ").concat(this.radius," 0 1 1 ").concat(this.maxX," ").concat(this.maxY)},valuePath:function(){return"M ".concat(this.zeroX," ").concat(this.zeroY," A ").concat(this.radius," ").concat(this.radius," 0 ").concat(this.largeArc," ").concat(this.sweep," ").concat(this.valueX," ").concat(this.valueY)},zeroRadians:function(){return this.mapRange(this.min>0&&this.max>0?this.min:0,this.min,this.max,this.minRadians,this.maxRadians)},valueRadians:function(){return this.mapRange(this.value,this.min,this.max,this.minRadians,this.maxRadians)},minX:function(){return this.midX+Math.cos(this.minRadians)*this.radius},minY:function(){return this.midY-Math.sin(this.minRadians)*this.radius},maxX:function(){return this.midX+Math.cos(this.maxRadians)*this.radius},maxY:function(){return this.midY-Math.sin(this.maxRadians)*this.radius},zeroX:function(){return this.midX+Math.cos(this.zeroRadians)*this.radius},zeroY:function(){return this.midY-Math.sin(this.zeroRadians)*this.radius},valueX:function(){return this.midX+Math.cos(this.valueRadians)*this.radius},valueY:function(){return this.midY-Math.sin(this.valueRadians)*this.radius},largeArc:function(){return Math.abs(this.zeroRadians-this.valueRadians)<Math.PI?0:1},sweep:function(){return this.valueRadians>this.zeroRadians?0:1},valueToDisplay:function(){return this.valueTemplate.replace(/{value}/g,this.value)}}};function e(n,e,t,i,a,s,o,r,d,h){"boolean"!=typeof o&&(d=r,r=o,o=!1);const u="function"==typeof t?t.options:t;let l;if(n&&n.render&&(u.render=n.render,u.staticRenderFns=n.staticRenderFns,u._compiled=!0,a&&(u.functional=!0)),i&&(u._scopeId=i),s?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),e&&e.call(this,d(n)),n&&n._registeredComponents&&n._registeredComponents.add(s)},u._ssrRegister=l):e&&(l=o?function(n){e.call(this,h(n,this.$root.$options.shadowRoot))}:function(n){e.call(this,r(n))}),l)if(u.functional){const n=u.render;u.render=function(e,t){return l.call(t),n(e,t)}}else{const n=u.beforeCreate;u.beforeCreate=n?[].concat(n,l):[l]}return t}const t="undefined"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());function i(n){return(n,e)=>o(n,e)}let a;const s={};function o(n,e){const i=t?e.media||"default":n,o=s[i]||(s[i]={ids:new Set,styles:[]});if(!o.ids.has(n)){o.ids.add(n);let t=e.source;if(e.map&&(t+="\n/*# sourceURL="+e.map.sources[0]+" */",t+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(e.map))))+" */"),o.element||(o.element=document.createElement("style"),o.element.type="text/css",e.media&&o.element.setAttribute("media",e.media),void 0===a&&(a=document.head||document.getElementsByTagName("head")[0]),a.appendChild(o.element)),"styleSheet"in o.element)o.styles.push(t),o.element.styleSheet.cssText=o.styles.filter(Boolean).join("\n");else{const n=o.ids.size-1,e=document.createTextNode(t),i=o.element.childNodes;i[n]&&o.element.removeChild(i[n]),i.length?o.element.insertBefore(e,i[n]):o.element.appendChild(e)}}}var r=n,d=function(){var n=this,e=n._self._c||n.$createElement;return e("div",{class:n.containerClass},[e("svg",{attrs:{viewBox:"0 0 100 100",width:n.size,height:n.size},on:{click:n.onClick,mousedown:n.onMouseDown,mouseup:n.onMouseUp,touchstart:n.onTouchStart,touchend:n.onTouchEnd}},[e("path",{staticClass:"p-knob-range",attrs:{d:n.rangePath,"stroke-width":n.strokeWidth,stroke:n.rangeColor}}),n._v(" "),e("path",{staticClass:"p-knob-value",attrs:{d:n.valuePath,"stroke-width":n.strokeWidth,stroke:n.valueColor}}),n._v(" "),n.showValue?e("text",{staticClass:"p-knob-text",attrs:{x:50,y:57,"text-anchor":"middle",fill:n.textColor}},[n._v("\n      "+n._s(n.valueToDisplay)+"\n    ")]):n._e()])])};d._withStripped=!0;var h=e({render:d,staticRenderFns:[]},(function(n){n&&n("data-v-62bc2b93_0",{source:"\n@-webkit-keyframes dash-frame {\n100% {\n      stroke-dashoffset: 0;\n}\n}\n@keyframes dash-frame {\n100% {\n      stroke-dashoffset: 0;\n}\n}\n.p-knob-range {\n  fill: none;\n  -webkit-transition: stroke .1s ease-in;\n  transition: stroke .1s ease-in;\n}\n.p-knob-value {\n  -webkit-animation-name: dash-frame;\n          animation-name: dash-frame;\n  -webkit-animation-fill-mode: forwards;\n          animation-fill-mode: forwards;\n  fill: none;\n}\n.p-knob-text {\n  font-size: 1.3rem;\n  text-align: center;\n}\n",map:{version:3,sources:["/Users/nangongpo/Desktop/开源学习/primevue2/src/components/knob/Knob.vue"],names:[],mappings:";AA6NA;AACA;MACA,oBAAA;AACA;AACA;AAJA;AACA;MACA,oBAAA;AACA;AACA;AACA;EACA,UAAA;EACA,sCAAA;EAAA,8BAAA;AACA;AACA;EACA,kCAAA;UAAA,0BAAA;EACA,qCAAA;UAAA,6BAAA;EACA,UAAA;AACA;AACA;EACA,iBAAA;EACA,kBAAA;AACA",file:"Knob.vue",sourcesContent:['<template>\n  <div :class="containerClass">\n    <svg\n      viewBox="0 0 100 100"\n      :width="size"\n      :height="size"\n      @click="onClick"\n      @mousedown="onMouseDown"\n      @mouseup="onMouseUp"\n      @touchstart="onTouchStart"\n      @touchend="onTouchEnd">\n      <path :d="rangePath" :stroke-width="strokeWidth" :stroke="rangeColor" class="p-knob-range"></path>\n      <path :d="valuePath" :stroke-width="strokeWidth" :stroke="valueColor" class="p-knob-value"></path>\n      <text v-if="showValue" :x="50" :y="57" text-anchor="middle" :fill="textColor" class="p-knob-text">\n        {{ valueToDisplay }}\n      </text>\n    </svg>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'Knob\',\n  data() {\n    return {\n      radius: 40,\n      midX: 50,\n      midY: 50,\n      minRadians: 4 * Math.PI / 3,\n      maxRadians: -Math.PI / 3\n    }\n  },\n  props: {\n    value: {\n      type: Number,\n      default: null\n    },\n    size: {\n      type: Number,\n      default: 100\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    readonly: {\n      type: Boolean,\n      default: false\n    },\n    step: {\n      type: Number,\n      default: 1\n    },\n    min: {\n      type: Number,\n      default: 0\n    },\n    max: {\n      type: Number,\n      default: 100\n    },\n    valueColor: {\n      type: String,\n      default: \'var(--primary-color, Black)\'\n    },\n    rangeColor: {\n      type: String,\n      default: \'var(--surface-border, LightGray)\'\n    },\n    textColor: {\n      type: String,\n      default: \'var(--text-color-secondary, Black)\'\n    },\n    strokeWidth: {\n      type: Number,\n      default: 14\n    },\n    showValue: {\n      type: Boolean,\n      default: true\n    },\n    valueTemplate: {\n      type: String,\n      default: \'{value}\'\n    }\n  },\n  methods: {\n    updateValue(offsetX, offsetY) {\n      let dx = offsetX - this.size / 2\n      let dy = this.size / 2 - offsetY\n      let angle = Math.atan2(dy, dx)\n      let start = -Math.PI / 2 - Math.PI / 6\n      this.updateModel(angle, start)\n    },\n    updateModel(angle, start) {\n      let mappedValue\n      if (angle > this.maxRadians)\n        mappedValue = this.mapRange(angle, this.minRadians, this.maxRadians, this.min, this.max)\n      else if (angle < start)\n        mappedValue = this.mapRange(angle + 2 * Math.PI, this.minRadians, this.maxRadians, this.min, this.max)\n      else\n        return\n\n      let newValue = Math.round((mappedValue - this.min) / this.step) * this.step + this.min\n      this.$emit(\'input\', newValue)\n      this.$emit(\'change\', newValue)\n    },\n    mapRange(x, inMin, inMax, outMin, outMax) {\n      return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin\n    },\n    onClick(event) {\n      if (!this.disabled && !this.readonly) {\n        this.updateValue(event.offsetX, event.offsetY)\n      }\n    },\n    onMouseDown(event) {\n      if (!this.disabled && !this.readonly) {\n        window.addEventListener(\'mousemove\', this.onMouseMove)\n        window.addEventListener(\'mouseup\', this.onMouseUp)\n        event.preventDefault()\n      }\n    },\n    onMouseUp(event) {\n      if (!this.disabled && !this.readonly) {\n        window.removeEventListener(\'mousemove\', this.onMouseMove)\n        window.removeEventListener(\'mouseup\', this.onMouseUp)\n        event.preventDefault()\n      }\n    },\n    onTouchStart(event) {\n      if (!this.disabled && !this.readonly) {\n        window.addEventListener(\'touchmove\', this.onTouchMove)\n        window.addEventListener(\'touchend\', this.onTouchEnd)\n        event.preventDefault()\n      }\n    },\n    onTouchEnd(event) {\n      if (!this.disabled && !this.readonly) {\n        window.removeEventListener(\'touchmove\', this.onTouchMove)\n        window.removeEventListener(\'touchend\', this.onTouchEnd)\n        event.preventDefault()\n      }\n    },\n    onMouseMove(event) {\n      if (!this.disabled && !this.readonly) {\n        this.updateValue(event.offsetX, event.offsetY)\n        event.preventDefault()\n      }\n    },\n    onTouchMove(event) {\n      if (!this.disabled && !this.readonly && event.touches.length == 1) {\n        const rect = this.$el.getBoundingClientRect()\n        const touch = event.targetTouches.item(0)\n        const offsetX = touch.clientX - rect.left\n        const offsetY = touch.clientY - rect.top\n        this.updateValue(offsetX, offsetY)\n      }\n    }\n  },\n  computed: {\n    containerClass() {\n      return [\n        \'p-knob p-component\', {\n          \'p-disabled\': this.disabled\n        }\n      ]\n    },\n    rangePath() {\n      return `M ${this.minX} ${this.minY} A ${this.radius} ${this.radius} 0 1 1 ${this.maxX} ${this.maxY}`\n    },\n    valuePath() {\n      return `M ${this.zeroX} ${this.zeroY} A ${this.radius} ${this.radius} 0 ${this.largeArc} ${this.sweep} ${this.valueX} ${this.valueY}`\n    },\n    zeroRadians() {\n      if (this.min > 0 && this.max > 0)\n        return this.mapRange(this.min, this.min, this.max, this.minRadians, this.maxRadians)\n      else\n        return this.mapRange(0, this.min, this.max, this.minRadians, this.maxRadians)\n    },\n    valueRadians() {\n      return this.mapRange(this.value, this.min, this.max, this.minRadians, this.maxRadians)\n    },\n    minX() {\n      return this.midX + Math.cos(this.minRadians) * this.radius\n    },\n    minY() {\n      return this.midY - Math.sin(this.minRadians) * this.radius\n    },\n    maxX() {\n      return this.midX + Math.cos(this.maxRadians) * this.radius\n    },\n    maxY() {\n      return this.midY - Math.sin(this.maxRadians) * this.radius\n    },\n    zeroX() {\n      return this.midX + Math.cos(this.zeroRadians) * this.radius\n    },\n    zeroY() {\n      return this.midY - Math.sin(this.zeroRadians) * this.radius\n    },\n    valueX() {\n      return this.midX + Math.cos(this.valueRadians) * this.radius\n    },\n    valueY() {\n      return this.midY - Math.sin(this.valueRadians) * this.radius\n    },\n    largeArc() {\n      return Math.abs(this.zeroRadians - this.valueRadians) < Math.PI ? 0 : 1\n    },\n    sweep() {\n      return this.valueRadians > this.zeroRadians ? 0 : 1\n    },\n    valueToDisplay() {\n      return this.valueTemplate.replace(/{value}/g, this.value)\n    }\n  }\n}\n//Inspired from https://github.com/kramer99/vue-knob-control\n<\/script>\n\n<style>\n@keyframes dash-frame {\n  100% {\n      stroke-dashoffset: 0;\n  }\n}\n.p-knob-range {\n  fill: none;\n  transition: stroke .1s ease-in;\n}\n.p-knob-value {\n  animation-name: dash-frame;\n  animation-fill-mode: forwards;\n  fill: none;\n}\n.p-knob-text {\n  font-size: 1.3rem;\n  text-align: center;\n}\n</style>\n']},media:void 0})}),r,undefined,false,undefined,!1,i,void 0,void 0);export{h as default};
