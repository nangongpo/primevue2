{"version":3,"file":"quill-delta-legacy-D1eAK-aI.js","sources":["../../node_modules/quill-delta/dist/AttributeMap.js","../../node_modules/quill-delta/dist/Op.js","../../node_modules/quill-delta/dist/OpIterator.js","../../node_modules/quill-delta/dist/Delta.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cloneDeep = require(\"lodash.clonedeep\");\nconst isEqual = require(\"lodash.isequal\");\nvar AttributeMap;\n(function (AttributeMap) {\n    function compose(a = {}, b = {}, keepNull = false) {\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        let attributes = cloneDeep(b);\n        if (!keepNull) {\n            attributes = Object.keys(attributes).reduce((copy, key) => {\n                if (attributes[key] != null) {\n                    copy[key] = attributes[key];\n                }\n                return copy;\n            }, {});\n        }\n        for (const key in a) {\n            if (a[key] !== undefined && b[key] === undefined) {\n                attributes[key] = a[key];\n            }\n        }\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.compose = compose;\n    function diff(a = {}, b = {}) {\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        const attributes = Object.keys(a)\n            .concat(Object.keys(b))\n            .reduce((attrs, key) => {\n            if (!isEqual(a[key], b[key])) {\n                attrs[key] = b[key] === undefined ? null : b[key];\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.diff = diff;\n    function invert(attr = {}, base = {}) {\n        attr = attr || {};\n        const baseInverted = Object.keys(base).reduce((memo, key) => {\n            if (base[key] !== attr[key] && attr[key] !== undefined) {\n                memo[key] = base[key];\n            }\n            return memo;\n        }, {});\n        return Object.keys(attr).reduce((memo, key) => {\n            if (attr[key] !== base[key] && base[key] === undefined) {\n                memo[key] = null;\n            }\n            return memo;\n        }, baseInverted);\n    }\n    AttributeMap.invert = invert;\n    function transform(a, b, priority = false) {\n        if (typeof a !== 'object') {\n            return b;\n        }\n        if (typeof b !== 'object') {\n            return undefined;\n        }\n        if (!priority) {\n            return b; // b simply overwrites us without priority\n        }\n        const attributes = Object.keys(b).reduce((attrs, key) => {\n            if (a[key] === undefined) {\n                attrs[key] = b[key]; // null is a valid value\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.transform = transform;\n})(AttributeMap || (AttributeMap = {}));\nexports.default = AttributeMap;\n//# sourceMappingURL=AttributeMap.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Op;\n(function (Op) {\n    function length(op) {\n        if (typeof op.delete === 'number') {\n            return op.delete;\n        }\n        else if (typeof op.retain === 'number') {\n            return op.retain;\n        }\n        else if (typeof op.retain === 'object' && op.retain !== null) {\n            return 1;\n        }\n        else {\n            return typeof op.insert === 'string' ? op.insert.length : 1;\n        }\n    }\n    Op.length = length;\n})(Op || (Op = {}));\nexports.default = Op;\n//# sourceMappingURL=Op.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Op_1 = require(\"./Op\");\nclass Iterator {\n    constructor(ops) {\n        this.ops = ops;\n        this.index = 0;\n        this.offset = 0;\n    }\n    hasNext() {\n        return this.peekLength() < Infinity;\n    }\n    next(length) {\n        if (!length) {\n            length = Infinity;\n        }\n        const nextOp = this.ops[this.index];\n        if (nextOp) {\n            const offset = this.offset;\n            const opLength = Op_1.default.length(nextOp);\n            if (length >= opLength - offset) {\n                length = opLength - offset;\n                this.index += 1;\n                this.offset = 0;\n            }\n            else {\n                this.offset += length;\n            }\n            if (typeof nextOp.delete === 'number') {\n                return { delete: length };\n            }\n            else {\n                const retOp = {};\n                if (nextOp.attributes) {\n                    retOp.attributes = nextOp.attributes;\n                }\n                if (typeof nextOp.retain === 'number') {\n                    retOp.retain = length;\n                }\n                else if (typeof nextOp.retain === 'object' &&\n                    nextOp.retain !== null) {\n                    // offset should === 0, length should === 1\n                    retOp.retain = nextOp.retain;\n                }\n                else if (typeof nextOp.insert === 'string') {\n                    retOp.insert = nextOp.insert.substr(offset, length);\n                }\n                else {\n                    // offset should === 0, length should === 1\n                    retOp.insert = nextOp.insert;\n                }\n                return retOp;\n            }\n        }\n        else {\n            return { retain: Infinity };\n        }\n    }\n    peek() {\n        return this.ops[this.index];\n    }\n    peekLength() {\n        if (this.ops[this.index]) {\n            // Should never return 0 if our index is being managed correctly\n            return Op_1.default.length(this.ops[this.index]) - this.offset;\n        }\n        else {\n            return Infinity;\n        }\n    }\n    peekType() {\n        const op = this.ops[this.index];\n        if (op) {\n            if (typeof op.delete === 'number') {\n                return 'delete';\n            }\n            else if (typeof op.retain === 'number' ||\n                (typeof op.retain === 'object' && op.retain !== null)) {\n                return 'retain';\n            }\n            else {\n                return 'insert';\n            }\n        }\n        return 'retain';\n    }\n    rest() {\n        if (!this.hasNext()) {\n            return [];\n        }\n        else if (this.offset === 0) {\n            return this.ops.slice(this.index);\n        }\n        else {\n            const offset = this.offset;\n            const index = this.index;\n            const next = this.next();\n            const rest = this.ops.slice(this.index);\n            this.offset = offset;\n            this.index = index;\n            return [next].concat(rest);\n        }\n    }\n}\nexports.default = Iterator;\n//# sourceMappingURL=OpIterator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AttributeMap = exports.OpIterator = exports.Op = void 0;\nconst diff = require(\"fast-diff\");\nconst cloneDeep = require(\"lodash.clonedeep\");\nconst isEqual = require(\"lodash.isequal\");\nconst AttributeMap_1 = require(\"./AttributeMap\");\nexports.AttributeMap = AttributeMap_1.default;\nconst Op_1 = require(\"./Op\");\nexports.Op = Op_1.default;\nconst OpIterator_1 = require(\"./OpIterator\");\nexports.OpIterator = OpIterator_1.default;\nconst NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\nconst getEmbedTypeAndData = (a, b) => {\n    if (typeof a !== 'object' || a === null) {\n        throw new Error(`cannot retain a ${typeof a}`);\n    }\n    if (typeof b !== 'object' || b === null) {\n        throw new Error(`cannot retain a ${typeof b}`);\n    }\n    const embedType = Object.keys(a)[0];\n    if (!embedType || embedType !== Object.keys(b)[0]) {\n        throw new Error(`embed types not matched: ${embedType} != ${Object.keys(b)[0]}`);\n    }\n    return [embedType, a[embedType], b[embedType]];\n};\nclass Delta {\n    constructor(ops) {\n        // Assume we are given a well formed ops\n        if (Array.isArray(ops)) {\n            this.ops = ops;\n        }\n        else if (ops != null && Array.isArray(ops.ops)) {\n            this.ops = ops.ops;\n        }\n        else {\n            this.ops = [];\n        }\n    }\n    static registerEmbed(embedType, handler) {\n        this.handlers[embedType] = handler;\n    }\n    static unregisterEmbed(embedType) {\n        delete this.handlers[embedType];\n    }\n    static getHandler(embedType) {\n        const handler = this.handlers[embedType];\n        if (!handler) {\n            throw new Error(`no handlers for embed type \"${embedType}\"`);\n        }\n        return handler;\n    }\n    insert(arg, attributes) {\n        const newOp = {};\n        if (typeof arg === 'string' && arg.length === 0) {\n            return this;\n        }\n        newOp.insert = arg;\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    }\n    delete(length) {\n        if (length <= 0) {\n            return this;\n        }\n        return this.push({ delete: length });\n    }\n    retain(length, attributes) {\n        if (typeof length === 'number' && length <= 0) {\n            return this;\n        }\n        const newOp = { retain: length };\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    }\n    push(newOp) {\n        let index = this.ops.length;\n        let lastOp = this.ops[index - 1];\n        newOp = cloneDeep(newOp);\n        if (typeof lastOp === 'object') {\n            if (typeof newOp.delete === 'number' &&\n                typeof lastOp.delete === 'number') {\n                this.ops[index - 1] = { delete: lastOp.delete + newOp.delete };\n                return this;\n            }\n            // Since it does not matter if we insert before or after deleting at the same index,\n            // always prefer to insert first\n            if (typeof lastOp.delete === 'number' && newOp.insert != null) {\n                index -= 1;\n                lastOp = this.ops[index - 1];\n                if (typeof lastOp !== 'object') {\n                    this.ops.unshift(newOp);\n                    return this;\n                }\n            }\n            if (isEqual(newOp.attributes, lastOp.attributes)) {\n                if (typeof newOp.insert === 'string' &&\n                    typeof lastOp.insert === 'string') {\n                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n                else if (typeof newOp.retain === 'number' &&\n                    typeof lastOp.retain === 'number') {\n                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n            }\n        }\n        if (index === this.ops.length) {\n            this.ops.push(newOp);\n        }\n        else {\n            this.ops.splice(index, 0, newOp);\n        }\n        return this;\n    }\n    chop() {\n        const lastOp = this.ops[this.ops.length - 1];\n        if (lastOp && typeof lastOp.retain === 'number' && !lastOp.attributes) {\n            this.ops.pop();\n        }\n        return this;\n    }\n    filter(predicate) {\n        return this.ops.filter(predicate);\n    }\n    forEach(predicate) {\n        this.ops.forEach(predicate);\n    }\n    map(predicate) {\n        return this.ops.map(predicate);\n    }\n    partition(predicate) {\n        const passed = [];\n        const failed = [];\n        this.forEach((op) => {\n            const target = predicate(op) ? passed : failed;\n            target.push(op);\n        });\n        return [passed, failed];\n    }\n    reduce(predicate, initialValue) {\n        return this.ops.reduce(predicate, initialValue);\n    }\n    changeLength() {\n        return this.reduce((length, elem) => {\n            if (elem.insert) {\n                return length + Op_1.default.length(elem);\n            }\n            else if (elem.delete) {\n                return length - elem.delete;\n            }\n            return length;\n        }, 0);\n    }\n    length() {\n        return this.reduce((length, elem) => {\n            return length + Op_1.default.length(elem);\n        }, 0);\n    }\n    slice(start = 0, end = Infinity) {\n        const ops = [];\n        const iter = new OpIterator_1.default(this.ops);\n        let index = 0;\n        while (index < end && iter.hasNext()) {\n            let nextOp;\n            if (index < start) {\n                nextOp = iter.next(start - index);\n            }\n            else {\n                nextOp = iter.next(end - index);\n                ops.push(nextOp);\n            }\n            index += Op_1.default.length(nextOp);\n        }\n        return new Delta(ops);\n    }\n    compose(other) {\n        const thisIter = new OpIterator_1.default(this.ops);\n        const otherIter = new OpIterator_1.default(other.ops);\n        const ops = [];\n        const firstOther = otherIter.peek();\n        if (firstOther != null &&\n            typeof firstOther.retain === 'number' &&\n            firstOther.attributes == null) {\n            let firstLeft = firstOther.retain;\n            while (thisIter.peekType() === 'insert' &&\n                thisIter.peekLength() <= firstLeft) {\n                firstLeft -= thisIter.peekLength();\n                ops.push(thisIter.next());\n            }\n            if (firstOther.retain - firstLeft > 0) {\n                otherIter.next(firstOther.retain - firstLeft);\n            }\n        }\n        const delta = new Delta(ops);\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else if (thisIter.peekType() === 'delete') {\n                delta.push(thisIter.next());\n            }\n            else {\n                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                const thisOp = thisIter.next(length);\n                const otherOp = otherIter.next(length);\n                if (otherOp.retain) {\n                    const newOp = {};\n                    if (typeof thisOp.retain === 'number') {\n                        newOp.retain =\n                            typeof otherOp.retain === 'number' ? length : otherOp.retain;\n                    }\n                    else {\n                        if (typeof otherOp.retain === 'number') {\n                            if (thisOp.retain == null) {\n                                newOp.insert = thisOp.insert;\n                            }\n                            else {\n                                newOp.retain = thisOp.retain;\n                            }\n                        }\n                        else {\n                            const action = thisOp.retain == null ? 'insert' : 'retain';\n                            const [embedType, thisData, otherData] = getEmbedTypeAndData(thisOp[action], otherOp.retain);\n                            const handler = Delta.getHandler(embedType);\n                            newOp[action] = {\n                                [embedType]: handler.compose(thisData, otherData, action === 'retain'),\n                            };\n                        }\n                    }\n                    // Preserve null when composing with a retain, otherwise remove it for inserts\n                    const attributes = AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n                    if (attributes) {\n                        newOp.attributes = attributes;\n                    }\n                    delta.push(newOp);\n                    // Optimization if rest of other is just retain\n                    if (!otherIter.hasNext() &&\n                        isEqual(delta.ops[delta.ops.length - 1], newOp)) {\n                        const rest = new Delta(thisIter.rest());\n                        return delta.concat(rest).chop();\n                    }\n                    // Other op should be delete, we could be an insert or retain\n                    // Insert + delete cancels out\n                }\n                else if (typeof otherOp.delete === 'number' &&\n                    (typeof thisOp.retain === 'number' ||\n                        (typeof thisOp.retain === 'object' && thisOp.retain !== null))) {\n                    delta.push(otherOp);\n                }\n            }\n        }\n        return delta.chop();\n    }\n    concat(other) {\n        const delta = new Delta(this.ops.slice());\n        if (other.ops.length > 0) {\n            delta.push(other.ops[0]);\n            delta.ops = delta.ops.concat(other.ops.slice(1));\n        }\n        return delta;\n    }\n    diff(other, cursor) {\n        if (this.ops === other.ops) {\n            return new Delta();\n        }\n        const strings = [this, other].map((delta) => {\n            return delta\n                .map((op) => {\n                if (op.insert != null) {\n                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n                }\n                const prep = delta === other ? 'on' : 'with';\n                throw new Error('diff() called ' + prep + ' non-document');\n            })\n                .join('');\n        });\n        const retDelta = new Delta();\n        const diffResult = diff(strings[0], strings[1], cursor, true);\n        const thisIter = new OpIterator_1.default(this.ops);\n        const otherIter = new OpIterator_1.default(other.ops);\n        diffResult.forEach((component) => {\n            let length = component[1].length;\n            while (length > 0) {\n                let opLength = 0;\n                switch (component[0]) {\n                    case diff.INSERT:\n                        opLength = Math.min(otherIter.peekLength(), length);\n                        retDelta.push(otherIter.next(opLength));\n                        break;\n                    case diff.DELETE:\n                        opLength = Math.min(length, thisIter.peekLength());\n                        thisIter.next(opLength);\n                        retDelta.delete(opLength);\n                        break;\n                    case diff.EQUAL:\n                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n                        const thisOp = thisIter.next(opLength);\n                        const otherOp = otherIter.next(opLength);\n                        if (isEqual(thisOp.insert, otherOp.insert)) {\n                            retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes));\n                        }\n                        else {\n                            retDelta.push(otherOp).delete(opLength);\n                        }\n                        break;\n                }\n                length -= opLength;\n            }\n        });\n        return retDelta.chop();\n    }\n    eachLine(predicate, newline = '\\n') {\n        const iter = new OpIterator_1.default(this.ops);\n        let line = new Delta();\n        let i = 0;\n        while (iter.hasNext()) {\n            if (iter.peekType() !== 'insert') {\n                return;\n            }\n            const thisOp = iter.peek();\n            const start = Op_1.default.length(thisOp) - iter.peekLength();\n            const index = typeof thisOp.insert === 'string'\n                ? thisOp.insert.indexOf(newline, start) - start\n                : -1;\n            if (index < 0) {\n                line.push(iter.next());\n            }\n            else if (index > 0) {\n                line.push(iter.next(index));\n            }\n            else {\n                if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n                    return;\n                }\n                i += 1;\n                line = new Delta();\n            }\n        }\n        if (line.length() > 0) {\n            predicate(line, {}, i);\n        }\n    }\n    invert(base) {\n        const inverted = new Delta();\n        this.reduce((baseIndex, op) => {\n            if (op.insert) {\n                inverted.delete(Op_1.default.length(op));\n            }\n            else if (typeof op.retain === 'number' && op.attributes == null) {\n                inverted.retain(op.retain);\n                return baseIndex + op.retain;\n            }\n            else if (op.delete || typeof op.retain === 'number') {\n                const length = (op.delete || op.retain);\n                const slice = base.slice(baseIndex, baseIndex + length);\n                slice.forEach((baseOp) => {\n                    if (op.delete) {\n                        inverted.push(baseOp);\n                    }\n                    else if (op.retain && op.attributes) {\n                        inverted.retain(Op_1.default.length(baseOp), AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n                    }\n                });\n                return baseIndex + length;\n            }\n            else if (typeof op.retain === 'object' && op.retain !== null) {\n                const slice = base.slice(baseIndex, baseIndex + 1);\n                const baseOp = new OpIterator_1.default(slice.ops).next();\n                const [embedType, opData, baseOpData] = getEmbedTypeAndData(op.retain, baseOp.insert);\n                const handler = Delta.getHandler(embedType);\n                inverted.retain({ [embedType]: handler.invert(opData, baseOpData) }, AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n                return baseIndex + 1;\n            }\n            return baseIndex;\n        }, 0);\n        return inverted.chop();\n    }\n    transform(arg, priority = false) {\n        priority = !!priority;\n        if (typeof arg === 'number') {\n            return this.transformPosition(arg, priority);\n        }\n        const other = arg;\n        const thisIter = new OpIterator_1.default(this.ops);\n        const otherIter = new OpIterator_1.default(other.ops);\n        const delta = new Delta();\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (thisIter.peekType() === 'insert' &&\n                (priority || otherIter.peekType() !== 'insert')) {\n                delta.retain(Op_1.default.length(thisIter.next()));\n            }\n            else if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else {\n                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                const thisOp = thisIter.next(length);\n                const otherOp = otherIter.next(length);\n                if (thisOp.delete) {\n                    // Our delete either makes their delete redundant or removes their retain\n                    continue;\n                }\n                else if (otherOp.delete) {\n                    delta.push(otherOp);\n                }\n                else {\n                    const thisData = thisOp.retain;\n                    const otherData = otherOp.retain;\n                    let transformedData = typeof otherData === 'object' && otherData !== null\n                        ? otherData\n                        : length;\n                    if (typeof thisData === 'object' &&\n                        thisData !== null &&\n                        typeof otherData === 'object' &&\n                        otherData !== null) {\n                        const embedType = Object.keys(thisData)[0];\n                        if (embedType === Object.keys(otherData)[0]) {\n                            const handler = Delta.getHandler(embedType);\n                            if (handler) {\n                                transformedData = {\n                                    [embedType]: handler.transform(thisData[embedType], otherData[embedType], priority),\n                                };\n                            }\n                        }\n                    }\n                    // We retain either their retain or insert\n                    delta.retain(transformedData, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));\n                }\n            }\n        }\n        return delta.chop();\n    }\n    transformPosition(index, priority = false) {\n        priority = !!priority;\n        const thisIter = new OpIterator_1.default(this.ops);\n        let offset = 0;\n        while (thisIter.hasNext() && offset <= index) {\n            const length = thisIter.peekLength();\n            const nextType = thisIter.peekType();\n            thisIter.next();\n            if (nextType === 'delete') {\n                index -= Math.min(length, index - offset);\n                continue;\n            }\n            else if (nextType === 'insert' && (offset < index || !priority)) {\n                index += length;\n            }\n            offset += length;\n        }\n        return index;\n    }\n}\nDelta.Op = Op_1.default;\nDelta.OpIterator = OpIterator_1.default;\nDelta.AttributeMap = AttributeMap_1.default;\nDelta.handlers = {};\nexports.default = Delta;\nif (typeof module === 'object') {\n    module.exports = Delta;\n    module.exports.default = Delta;\n}\n//# sourceMappingURL=Delta.js.map"],"names":["Object","defineProperty","AttributeMap_1","value","AttributeMap","cloneDeep","require$$0","isEqual","require$$1","compose","a","arguments","length","undefined","b","keepNull","_typeof","attributes","key","keys","reduce","copy","diff","concat","attrs","invert","attr","base","baseInverted","memo","transform","priority","AttributeMap$1","default","Op","Op_1","op","delete","retain","insert","Op$1","OpIterator","Iterator","_createClass","ops","_classCallCheck","this","index","offset","peekLength","Infinity","nextOp","opLength","retOp","substr","hasNext","slice","next","rest","exports","require$$2","require$$3","require$$4","OpIterator_1","require$$5","NULL_CHARACTER","String","fromCharCode","getEmbedTypeAndData","Error","embedType","Delta","Array","isArray","arg","newOp","push","lastOp","unshift","splice","pop","predicate","filter","forEach","map","passed","failed","initialValue","elem","start","end","iter","other","thisIter","otherIter","firstOther","peek","firstLeft","peekType","delta","Math","min","thisOp","otherOp","action","_getEmbedTypeAndData2","_slicedToArray","thisData","otherData","handler","getHandler","_defineProperty","chop","cursor","strings","join","retDelta","diffResult","component","INSERT","DELETE","EQUAL","newline","line","i","indexOf","inverted","baseIndex","baseOp","_getEmbedTypeAndData4","opData","baseOpData","transformPosition","transformedData","nextType","handlers","module"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}