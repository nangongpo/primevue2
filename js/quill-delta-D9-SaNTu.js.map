{"version":3,"file":"quill-delta-D9-SaNTu.js","sources":["../../node_modules/quill-delta/dist/AttributeMap.js","../../node_modules/quill-delta/dist/Op.js","../../node_modules/quill-delta/dist/OpIterator.js","../../node_modules/quill-delta/dist/Delta.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cloneDeep = require(\"lodash.clonedeep\");\nconst isEqual = require(\"lodash.isequal\");\nvar AttributeMap;\n(function (AttributeMap) {\n    function compose(a = {}, b = {}, keepNull = false) {\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        let attributes = cloneDeep(b);\n        if (!keepNull) {\n            attributes = Object.keys(attributes).reduce((copy, key) => {\n                if (attributes[key] != null) {\n                    copy[key] = attributes[key];\n                }\n                return copy;\n            }, {});\n        }\n        for (const key in a) {\n            if (a[key] !== undefined && b[key] === undefined) {\n                attributes[key] = a[key];\n            }\n        }\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.compose = compose;\n    function diff(a = {}, b = {}) {\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        const attributes = Object.keys(a)\n            .concat(Object.keys(b))\n            .reduce((attrs, key) => {\n            if (!isEqual(a[key], b[key])) {\n                attrs[key] = b[key] === undefined ? null : b[key];\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.diff = diff;\n    function invert(attr = {}, base = {}) {\n        attr = attr || {};\n        const baseInverted = Object.keys(base).reduce((memo, key) => {\n            if (base[key] !== attr[key] && attr[key] !== undefined) {\n                memo[key] = base[key];\n            }\n            return memo;\n        }, {});\n        return Object.keys(attr).reduce((memo, key) => {\n            if (attr[key] !== base[key] && base[key] === undefined) {\n                memo[key] = null;\n            }\n            return memo;\n        }, baseInverted);\n    }\n    AttributeMap.invert = invert;\n    function transform(a, b, priority = false) {\n        if (typeof a !== 'object') {\n            return b;\n        }\n        if (typeof b !== 'object') {\n            return undefined;\n        }\n        if (!priority) {\n            return b; // b simply overwrites us without priority\n        }\n        const attributes = Object.keys(b).reduce((attrs, key) => {\n            if (a[key] === undefined) {\n                attrs[key] = b[key]; // null is a valid value\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.transform = transform;\n})(AttributeMap || (AttributeMap = {}));\nexports.default = AttributeMap;\n//# sourceMappingURL=AttributeMap.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Op;\n(function (Op) {\n    function length(op) {\n        if (typeof op.delete === 'number') {\n            return op.delete;\n        }\n        else if (typeof op.retain === 'number') {\n            return op.retain;\n        }\n        else if (typeof op.retain === 'object' && op.retain !== null) {\n            return 1;\n        }\n        else {\n            return typeof op.insert === 'string' ? op.insert.length : 1;\n        }\n    }\n    Op.length = length;\n})(Op || (Op = {}));\nexports.default = Op;\n//# sourceMappingURL=Op.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Op_1 = require(\"./Op\");\nclass Iterator {\n    constructor(ops) {\n        this.ops = ops;\n        this.index = 0;\n        this.offset = 0;\n    }\n    hasNext() {\n        return this.peekLength() < Infinity;\n    }\n    next(length) {\n        if (!length) {\n            length = Infinity;\n        }\n        const nextOp = this.ops[this.index];\n        if (nextOp) {\n            const offset = this.offset;\n            const opLength = Op_1.default.length(nextOp);\n            if (length >= opLength - offset) {\n                length = opLength - offset;\n                this.index += 1;\n                this.offset = 0;\n            }\n            else {\n                this.offset += length;\n            }\n            if (typeof nextOp.delete === 'number') {\n                return { delete: length };\n            }\n            else {\n                const retOp = {};\n                if (nextOp.attributes) {\n                    retOp.attributes = nextOp.attributes;\n                }\n                if (typeof nextOp.retain === 'number') {\n                    retOp.retain = length;\n                }\n                else if (typeof nextOp.retain === 'object' &&\n                    nextOp.retain !== null) {\n                    // offset should === 0, length should === 1\n                    retOp.retain = nextOp.retain;\n                }\n                else if (typeof nextOp.insert === 'string') {\n                    retOp.insert = nextOp.insert.substr(offset, length);\n                }\n                else {\n                    // offset should === 0, length should === 1\n                    retOp.insert = nextOp.insert;\n                }\n                return retOp;\n            }\n        }\n        else {\n            return { retain: Infinity };\n        }\n    }\n    peek() {\n        return this.ops[this.index];\n    }\n    peekLength() {\n        if (this.ops[this.index]) {\n            // Should never return 0 if our index is being managed correctly\n            return Op_1.default.length(this.ops[this.index]) - this.offset;\n        }\n        else {\n            return Infinity;\n        }\n    }\n    peekType() {\n        const op = this.ops[this.index];\n        if (op) {\n            if (typeof op.delete === 'number') {\n                return 'delete';\n            }\n            else if (typeof op.retain === 'number' ||\n                (typeof op.retain === 'object' && op.retain !== null)) {\n                return 'retain';\n            }\n            else {\n                return 'insert';\n            }\n        }\n        return 'retain';\n    }\n    rest() {\n        if (!this.hasNext()) {\n            return [];\n        }\n        else if (this.offset === 0) {\n            return this.ops.slice(this.index);\n        }\n        else {\n            const offset = this.offset;\n            const index = this.index;\n            const next = this.next();\n            const rest = this.ops.slice(this.index);\n            this.offset = offset;\n            this.index = index;\n            return [next].concat(rest);\n        }\n    }\n}\nexports.default = Iterator;\n//# sourceMappingURL=OpIterator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AttributeMap = exports.OpIterator = exports.Op = void 0;\nconst diff = require(\"fast-diff\");\nconst cloneDeep = require(\"lodash.clonedeep\");\nconst isEqual = require(\"lodash.isequal\");\nconst AttributeMap_1 = require(\"./AttributeMap\");\nexports.AttributeMap = AttributeMap_1.default;\nconst Op_1 = require(\"./Op\");\nexports.Op = Op_1.default;\nconst OpIterator_1 = require(\"./OpIterator\");\nexports.OpIterator = OpIterator_1.default;\nconst NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\nconst getEmbedTypeAndData = (a, b) => {\n    if (typeof a !== 'object' || a === null) {\n        throw new Error(`cannot retain a ${typeof a}`);\n    }\n    if (typeof b !== 'object' || b === null) {\n        throw new Error(`cannot retain a ${typeof b}`);\n    }\n    const embedType = Object.keys(a)[0];\n    if (!embedType || embedType !== Object.keys(b)[0]) {\n        throw new Error(`embed types not matched: ${embedType} != ${Object.keys(b)[0]}`);\n    }\n    return [embedType, a[embedType], b[embedType]];\n};\nclass Delta {\n    constructor(ops) {\n        // Assume we are given a well formed ops\n        if (Array.isArray(ops)) {\n            this.ops = ops;\n        }\n        else if (ops != null && Array.isArray(ops.ops)) {\n            this.ops = ops.ops;\n        }\n        else {\n            this.ops = [];\n        }\n    }\n    static registerEmbed(embedType, handler) {\n        this.handlers[embedType] = handler;\n    }\n    static unregisterEmbed(embedType) {\n        delete this.handlers[embedType];\n    }\n    static getHandler(embedType) {\n        const handler = this.handlers[embedType];\n        if (!handler) {\n            throw new Error(`no handlers for embed type \"${embedType}\"`);\n        }\n        return handler;\n    }\n    insert(arg, attributes) {\n        const newOp = {};\n        if (typeof arg === 'string' && arg.length === 0) {\n            return this;\n        }\n        newOp.insert = arg;\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    }\n    delete(length) {\n        if (length <= 0) {\n            return this;\n        }\n        return this.push({ delete: length });\n    }\n    retain(length, attributes) {\n        if (typeof length === 'number' && length <= 0) {\n            return this;\n        }\n        const newOp = { retain: length };\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    }\n    push(newOp) {\n        let index = this.ops.length;\n        let lastOp = this.ops[index - 1];\n        newOp = cloneDeep(newOp);\n        if (typeof lastOp === 'object') {\n            if (typeof newOp.delete === 'number' &&\n                typeof lastOp.delete === 'number') {\n                this.ops[index - 1] = { delete: lastOp.delete + newOp.delete };\n                return this;\n            }\n            // Since it does not matter if we insert before or after deleting at the same index,\n            // always prefer to insert first\n            if (typeof lastOp.delete === 'number' && newOp.insert != null) {\n                index -= 1;\n                lastOp = this.ops[index - 1];\n                if (typeof lastOp !== 'object') {\n                    this.ops.unshift(newOp);\n                    return this;\n                }\n            }\n            if (isEqual(newOp.attributes, lastOp.attributes)) {\n                if (typeof newOp.insert === 'string' &&\n                    typeof lastOp.insert === 'string') {\n                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n                else if (typeof newOp.retain === 'number' &&\n                    typeof lastOp.retain === 'number') {\n                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n            }\n        }\n        if (index === this.ops.length) {\n            this.ops.push(newOp);\n        }\n        else {\n            this.ops.splice(index, 0, newOp);\n        }\n        return this;\n    }\n    chop() {\n        const lastOp = this.ops[this.ops.length - 1];\n        if (lastOp && typeof lastOp.retain === 'number' && !lastOp.attributes) {\n            this.ops.pop();\n        }\n        return this;\n    }\n    filter(predicate) {\n        return this.ops.filter(predicate);\n    }\n    forEach(predicate) {\n        this.ops.forEach(predicate);\n    }\n    map(predicate) {\n        return this.ops.map(predicate);\n    }\n    partition(predicate) {\n        const passed = [];\n        const failed = [];\n        this.forEach((op) => {\n            const target = predicate(op) ? passed : failed;\n            target.push(op);\n        });\n        return [passed, failed];\n    }\n    reduce(predicate, initialValue) {\n        return this.ops.reduce(predicate, initialValue);\n    }\n    changeLength() {\n        return this.reduce((length, elem) => {\n            if (elem.insert) {\n                return length + Op_1.default.length(elem);\n            }\n            else if (elem.delete) {\n                return length - elem.delete;\n            }\n            return length;\n        }, 0);\n    }\n    length() {\n        return this.reduce((length, elem) => {\n            return length + Op_1.default.length(elem);\n        }, 0);\n    }\n    slice(start = 0, end = Infinity) {\n        const ops = [];\n        const iter = new OpIterator_1.default(this.ops);\n        let index = 0;\n        while (index < end && iter.hasNext()) {\n            let nextOp;\n            if (index < start) {\n                nextOp = iter.next(start - index);\n            }\n            else {\n                nextOp = iter.next(end - index);\n                ops.push(nextOp);\n            }\n            index += Op_1.default.length(nextOp);\n        }\n        return new Delta(ops);\n    }\n    compose(other) {\n        const thisIter = new OpIterator_1.default(this.ops);\n        const otherIter = new OpIterator_1.default(other.ops);\n        const ops = [];\n        const firstOther = otherIter.peek();\n        if (firstOther != null &&\n            typeof firstOther.retain === 'number' &&\n            firstOther.attributes == null) {\n            let firstLeft = firstOther.retain;\n            while (thisIter.peekType() === 'insert' &&\n                thisIter.peekLength() <= firstLeft) {\n                firstLeft -= thisIter.peekLength();\n                ops.push(thisIter.next());\n            }\n            if (firstOther.retain - firstLeft > 0) {\n                otherIter.next(firstOther.retain - firstLeft);\n            }\n        }\n        const delta = new Delta(ops);\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else if (thisIter.peekType() === 'delete') {\n                delta.push(thisIter.next());\n            }\n            else {\n                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                const thisOp = thisIter.next(length);\n                const otherOp = otherIter.next(length);\n                if (otherOp.retain) {\n                    const newOp = {};\n                    if (typeof thisOp.retain === 'number') {\n                        newOp.retain =\n                            typeof otherOp.retain === 'number' ? length : otherOp.retain;\n                    }\n                    else {\n                        if (typeof otherOp.retain === 'number') {\n                            if (thisOp.retain == null) {\n                                newOp.insert = thisOp.insert;\n                            }\n                            else {\n                                newOp.retain = thisOp.retain;\n                            }\n                        }\n                        else {\n                            const action = thisOp.retain == null ? 'insert' : 'retain';\n                            const [embedType, thisData, otherData] = getEmbedTypeAndData(thisOp[action], otherOp.retain);\n                            const handler = Delta.getHandler(embedType);\n                            newOp[action] = {\n                                [embedType]: handler.compose(thisData, otherData, action === 'retain'),\n                            };\n                        }\n                    }\n                    // Preserve null when composing with a retain, otherwise remove it for inserts\n                    const attributes = AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n                    if (attributes) {\n                        newOp.attributes = attributes;\n                    }\n                    delta.push(newOp);\n                    // Optimization if rest of other is just retain\n                    if (!otherIter.hasNext() &&\n                        isEqual(delta.ops[delta.ops.length - 1], newOp)) {\n                        const rest = new Delta(thisIter.rest());\n                        return delta.concat(rest).chop();\n                    }\n                    // Other op should be delete, we could be an insert or retain\n                    // Insert + delete cancels out\n                }\n                else if (typeof otherOp.delete === 'number' &&\n                    (typeof thisOp.retain === 'number' ||\n                        (typeof thisOp.retain === 'object' && thisOp.retain !== null))) {\n                    delta.push(otherOp);\n                }\n            }\n        }\n        return delta.chop();\n    }\n    concat(other) {\n        const delta = new Delta(this.ops.slice());\n        if (other.ops.length > 0) {\n            delta.push(other.ops[0]);\n            delta.ops = delta.ops.concat(other.ops.slice(1));\n        }\n        return delta;\n    }\n    diff(other, cursor) {\n        if (this.ops === other.ops) {\n            return new Delta();\n        }\n        const strings = [this, other].map((delta) => {\n            return delta\n                .map((op) => {\n                if (op.insert != null) {\n                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n                }\n                const prep = delta === other ? 'on' : 'with';\n                throw new Error('diff() called ' + prep + ' non-document');\n            })\n                .join('');\n        });\n        const retDelta = new Delta();\n        const diffResult = diff(strings[0], strings[1], cursor, true);\n        const thisIter = new OpIterator_1.default(this.ops);\n        const otherIter = new OpIterator_1.default(other.ops);\n        diffResult.forEach((component) => {\n            let length = component[1].length;\n            while (length > 0) {\n                let opLength = 0;\n                switch (component[0]) {\n                    case diff.INSERT:\n                        opLength = Math.min(otherIter.peekLength(), length);\n                        retDelta.push(otherIter.next(opLength));\n                        break;\n                    case diff.DELETE:\n                        opLength = Math.min(length, thisIter.peekLength());\n                        thisIter.next(opLength);\n                        retDelta.delete(opLength);\n                        break;\n                    case diff.EQUAL:\n                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n                        const thisOp = thisIter.next(opLength);\n                        const otherOp = otherIter.next(opLength);\n                        if (isEqual(thisOp.insert, otherOp.insert)) {\n                            retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes));\n                        }\n                        else {\n                            retDelta.push(otherOp).delete(opLength);\n                        }\n                        break;\n                }\n                length -= opLength;\n            }\n        });\n        return retDelta.chop();\n    }\n    eachLine(predicate, newline = '\\n') {\n        const iter = new OpIterator_1.default(this.ops);\n        let line = new Delta();\n        let i = 0;\n        while (iter.hasNext()) {\n            if (iter.peekType() !== 'insert') {\n                return;\n            }\n            const thisOp = iter.peek();\n            const start = Op_1.default.length(thisOp) - iter.peekLength();\n            const index = typeof thisOp.insert === 'string'\n                ? thisOp.insert.indexOf(newline, start) - start\n                : -1;\n            if (index < 0) {\n                line.push(iter.next());\n            }\n            else if (index > 0) {\n                line.push(iter.next(index));\n            }\n            else {\n                if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n                    return;\n                }\n                i += 1;\n                line = new Delta();\n            }\n        }\n        if (line.length() > 0) {\n            predicate(line, {}, i);\n        }\n    }\n    invert(base) {\n        const inverted = new Delta();\n        this.reduce((baseIndex, op) => {\n            if (op.insert) {\n                inverted.delete(Op_1.default.length(op));\n            }\n            else if (typeof op.retain === 'number' && op.attributes == null) {\n                inverted.retain(op.retain);\n                return baseIndex + op.retain;\n            }\n            else if (op.delete || typeof op.retain === 'number') {\n                const length = (op.delete || op.retain);\n                const slice = base.slice(baseIndex, baseIndex + length);\n                slice.forEach((baseOp) => {\n                    if (op.delete) {\n                        inverted.push(baseOp);\n                    }\n                    else if (op.retain && op.attributes) {\n                        inverted.retain(Op_1.default.length(baseOp), AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n                    }\n                });\n                return baseIndex + length;\n            }\n            else if (typeof op.retain === 'object' && op.retain !== null) {\n                const slice = base.slice(baseIndex, baseIndex + 1);\n                const baseOp = new OpIterator_1.default(slice.ops).next();\n                const [embedType, opData, baseOpData] = getEmbedTypeAndData(op.retain, baseOp.insert);\n                const handler = Delta.getHandler(embedType);\n                inverted.retain({ [embedType]: handler.invert(opData, baseOpData) }, AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n                return baseIndex + 1;\n            }\n            return baseIndex;\n        }, 0);\n        return inverted.chop();\n    }\n    transform(arg, priority = false) {\n        priority = !!priority;\n        if (typeof arg === 'number') {\n            return this.transformPosition(arg, priority);\n        }\n        const other = arg;\n        const thisIter = new OpIterator_1.default(this.ops);\n        const otherIter = new OpIterator_1.default(other.ops);\n        const delta = new Delta();\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (thisIter.peekType() === 'insert' &&\n                (priority || otherIter.peekType() !== 'insert')) {\n                delta.retain(Op_1.default.length(thisIter.next()));\n            }\n            else if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else {\n                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                const thisOp = thisIter.next(length);\n                const otherOp = otherIter.next(length);\n                if (thisOp.delete) {\n                    // Our delete either makes their delete redundant or removes their retain\n                    continue;\n                }\n                else if (otherOp.delete) {\n                    delta.push(otherOp);\n                }\n                else {\n                    const thisData = thisOp.retain;\n                    const otherData = otherOp.retain;\n                    let transformedData = typeof otherData === 'object' && otherData !== null\n                        ? otherData\n                        : length;\n                    if (typeof thisData === 'object' &&\n                        thisData !== null &&\n                        typeof otherData === 'object' &&\n                        otherData !== null) {\n                        const embedType = Object.keys(thisData)[0];\n                        if (embedType === Object.keys(otherData)[0]) {\n                            const handler = Delta.getHandler(embedType);\n                            if (handler) {\n                                transformedData = {\n                                    [embedType]: handler.transform(thisData[embedType], otherData[embedType], priority),\n                                };\n                            }\n                        }\n                    }\n                    // We retain either their retain or insert\n                    delta.retain(transformedData, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));\n                }\n            }\n        }\n        return delta.chop();\n    }\n    transformPosition(index, priority = false) {\n        priority = !!priority;\n        const thisIter = new OpIterator_1.default(this.ops);\n        let offset = 0;\n        while (thisIter.hasNext() && offset <= index) {\n            const length = thisIter.peekLength();\n            const nextType = thisIter.peekType();\n            thisIter.next();\n            if (nextType === 'delete') {\n                index -= Math.min(length, index - offset);\n                continue;\n            }\n            else if (nextType === 'insert' && (offset < index || !priority)) {\n                index += length;\n            }\n            offset += length;\n        }\n        return index;\n    }\n}\nDelta.Op = Op_1.default;\nDelta.OpIterator = OpIterator_1.default;\nDelta.AttributeMap = AttributeMap_1.default;\nDelta.handlers = {};\nexports.default = Delta;\nif (typeof module === 'object') {\n    module.exports = Delta;\n    module.exports.default = Delta;\n}\n//# sourceMappingURL=Delta.js.map"],"names":["AttributeMap_1","cloneDeep","require$$0","isEqual","require$$1","AttributeMap","compose","a","b","keepNull","attributes","copy","key","diff","attrs","invert","attr","base","baseInverted","memo","transform","priority","Op_1","Op","length","op","OpIterator","Iterator","ops","nextOp","offset","opLength","retOp","index","next","rest","exports","require$$2","require$$3","require$$4","OpIterator_1","require$$5","NULL_CHARACTER","getEmbedTypeAndData","embedType","Delta","handler","arg","newOp","lastOp","predicate","passed","failed","initialValue","elem","start","end","iter","other","thisIter","otherIter","firstOther","firstLeft","delta","thisOp","otherOp","action","thisData","otherData","cursor","strings","prep","retDelta","diffResult","component","newline","line","inverted","baseIndex","baseOp","slice","opData","baseOpData","transformedData","nextType","module"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}